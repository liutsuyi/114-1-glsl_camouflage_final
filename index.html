<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>GlslCanvas</title>
  <script type="text/javascript"
    src="dist/GlslCanvas.js"></script>
  <style>
    /* 聶永貞風格：簡潔、留白、質感紙色與沉穩深色對比 */
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(180deg,#0b0f0e 0%, #0f1410 100%);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      color: #111;
      /* 優先使用明體系字型；若系統沒有則退至 Noto Serif TC / serif */
      font-family: "PMingLiU", "MingLiU", "Noto Serif TC", serif;
      font-size: 15px;
      line-height: 1.4;
    }

    /* 畫布靠右以騰出左側控制區 */
    #glslCanvas {
      position: absolute;
      top: 50%;
      left: 60%;
      /* 移除 CSS 變形縮放，改用實際像素尺寸 */
      transform: translate(-50%, -50%);
      border-radius: 10px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.6);
      background: #000;
    }

    /* 左側控制面板：紙色、陰影、留白 */
    #ui {
      position: fixed;
      /* left/top will be positioned by JS to stick to canvas left edge */
      left: auto;
      top: auto;
      transform: none;
      z-index: 11;
      background: rgba(250,246,241,0.98);
      color: #2b231f;
      padding: 16px 18px;
      border-radius: 10px;
      box-shadow: 0 8px 28px rgba(6,10,8,0.6);
      /* 擴寬控制面板到約 140%（240 * 1.4 ≈ 336px） */
      max-width: 336px;
      /* 高度將在 JS 依 canvas 高度設定，這裡預設允許滾動 */
      max-height: none;
      overflow: hidden;
      border: 1px solid rgba(30,30,30,0.04);
    }

    #ui label { display: block; margin-bottom: 10px; font-weight: 500; }
    #ui .small { font-size: 12px; color: #7a6f67; margin-top: 4px; }

    /* select 樣式 */
    #textureSetSelect {
      width: 100%;
      padding: 8px 10px;
      font-family: inherit;
      background: #fff;
      color: #2b231f; /* 深色文字，增加可讀性 */
      border: 1px solid rgba(40,40,40,0.06);
      border-radius: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }

    /* range (slider) 基本樣式 */
    input[type=range] {
      width: 100%;
      margin-top: 6px;
      background: transparent;
    }
    input[type=range]::-webkit-slider-runnable-track {
      height: 8px;
      background: linear-gradient(90deg,#e9dacf,#d8c9bd);
      border-radius: 6px;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      margin-top: -5px;
      background: #2b231f;
      border-radius: 50%;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
      border: 2px solid #fff3ec;
    }
    input[type=range]::-moz-range-track {
      height: 8px;
      background: linear-gradient(90deg,#e9dacf,#d8c9bd);
      border-radius: 6px;
    }
    input[type=range]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #2b231f;
      border-radius: 50%;
      border: 2px solid #fff3ec;
    }

    /* 小字說明 */
    #textureSetNote { font-size: 12px; color: #6d625b; margin-top:6px; }

    /* 調整 label 與控制元件間距 */
    #ui > div { margin-bottom: 12px; }
  </style>
</head>

<body>
  <canvas id="glslCanvas" data-fragment-url="shader/environment_v1.frag" width="1080" height="720"
    data-textures="data/0_Top%20Canopy%20Leaves_alpha.png,data/1_Foreground_alpha.png,data/2_Mid-Foreground_alpha.png,data/3_Midground_alpha.png,data/4_Back-Midground_alpha.png,data/5_Background.png"></canvas>

  <!-- UI: focus & max blur sliders -->
  <div id="ui">
    <div style="margin-bottom:8px">
      <label>焦距: <input id="focusSlider" type="range" min="0" max="1" step="0.01" value="0.0"></label>
    </div>
    <!-- Texture Set selector 暫時註解，不顯示也不執行；如需恢復，移除下方註解即可 -->
    <!--
    <div style="margin-bottom:8px">
      <label>Texture Set: 
        <select id="textureSetSelect">
          <option value="0">Set 1</option>
          <option value="1">Set 2</option>
        </select>
      </label>
      <div style="font-size:12px;color:#ccc" id="textureSetNote">Using Set 1</div>
    </div>
    -->
    <div>
      <label>光圈: <input id="maxBlurSlider" type="range" min="0" max="1" step="0.01" value="0.5"></label>
    </div>
    <div style="margin-top:8px">
      <label>Fox Size: <input id="foxSizeSlider" type="range" min="0.2" max="1.0" step="0.01" value="0.2"></label>
      <div class="small">狐狸尺寸: <span id="foxSizeLabel">1%</span></div>
    </div>
    <div style="margin-top:8px">
      <!-- Fox Feather slider removed; fixed feather value enforced in JS -->
  
    </div>
    <div style="margin-top:8px">
      <label style="display:flex;align-items:center;gap:8px"><input id="foxOverlayToggle" type="checkbox" checked> <span style="font-weight:500">Fox Overlay</span></label>
      <div class="small">若勾選，狐狸會以 overlay 方式渲染於最前方，確保可見。</div>
      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <button id="foxLayerBackBtn" title="向後一層">向後</button>
        <button id="foxLayerForwardBtn" title="向前一層">向前</button>
        <div class="small" style="margin-left:6px">目前圖層: <span id="foxLayerLabel">0</span></div>
      </div>
    </div>
    <div style="margin-top:8px">
      <label style="display:flex;align-items:center;gap:8px"><input id="foxClothToggle" type="checkbox"> <span style="font-weight:500">穿上偽裝服</span></label>
      <div class="small">若勾選，將以預設或上傳的偽裝服套用於狐狸（會跟隨翻轉/模糊/羽化）。</div>
      <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
        <input id="foxClothUpload" type="file" accept="image/*" style="flex:1">
      </div>
      <div style="margin-top:6px;">
        <button id="foxClothLoadDefault">載入預設偽裝</button>
      </div>
    </div>
    <!--
      場景層次圖片 (Scene layer textures)
      -------------------------------
      以下區域列出目前在畫布上使用的場景貼圖 (u_tex0 .. u_tex5)。
      這裡提供直接替換上傳的輸入欄位，維護或更換時只需選取新圖片即可。
      若你偏好直接以路徑管理，可修改 canvas 的 `data-textures` 屬性。
    -->
    <div style="margin-top:12px; border-top:1px solid rgba(0,0,0,0.04); padding-top:10px">
      <label style="font-weight:600">場景圖層 (可替換)</label>
      <div class="small">u_tex0 → u_tex5。若需更改，展開清單進行替換。</div>
      <details id="textureListWrap" style="margin-top:6px">
        <summary style="cursor:pointer; font-size:13px; color:#2b231f">展開/收合圖層清單</summary>
        <div id="textureList" style="margin-top:8px; display:flex; flex-direction:column; gap:6px; max-height: 180px; overflow:auto">
          <!-- JS will populate items here: each row contains a label and a file input -->
        </div>
      </details>
    </div>

    <!-- DCCU Camouflage Preview Block -->
    <div style="margin-top:12px; border-top:1px solid rgba(0,0,0,0.04); padding-top:10px">
      <label style="font-weight:600">DCCU 迷彩預覽</label>
      <div class="small">在此預覽並調整 DCCU shader 參數。</div>
      <canvas id="dccuCanvas" width="360" height="240" data-fragment-url="shader/dccu_camouflage.frag" style="width:100%; height:auto; border-radius:8px; box-shadow:0 8px 22px rgba(0,0,0,0.35); background:#000; display:block; margin-top:8px"></canvas>
      <div style="margin-top:10px">
        <label>Scale: <input id="dccuScale" type="range" min="0.1" max="5.0" step="0.01" value="1.0"></label>
        <div class="small">圖樣密度縮放（最小 0.1，方塊可更大）</div>
      </div>
      <!-- 移除 Noise Amp 控制：效果不明顯，取消該參數 -->
      <div style="margin-top:8px">
        <label>Rotate: <input id="dccuRotate" type="range" min="-25" max="25" step="0.5" value="0"></label>
        <div class="small">格網旋轉（預設為端正 0°）</div>
      </div>
      <div style="margin-top:8px">
        <label style="display:flex;align-items:center;gap:8px">比例：深 (D) <input id="dccuRatioD" type="range" min="0.0" max="1.0" step="0.01" value="0.36"><span id="dccuRatioDLabel" class="small">36%</span></label>
        <label style="display:flex;align-items:center;gap:8px">比例：暗 (B) <input id="dccuRatioB" type="range" min="0.0" max="1.0" step="0.01" value="0.22"><span id="dccuRatioBLabel" class="small">22%</span></label>
        <label style="display:flex;align-items:center;gap:8px">比例：中 (C) <input id="dccuRatioC" type="range" min="0.0" max="1.0" step="0.01" value="0.13"><span id="dccuRatioCLabel" class="small">13%</span></label>
        <div class="small">三者相加後，其餘即為淺 (A)。系統自動正規化。</div>
      </div>
      <!-- Cell Size 效果不佳，已移除 -->
    </div>
  </div>
</body>
<script>
  var canvas = document.getElementById("glslCanvas");
  var sandbox = new GlslCanvas(canvas);
  // Mouse-movement flip state (velocity-driven, smoothed)
  var _prevMouseX = null;
  var _prevMouseY = null;
  var _prevTime = null;
  var _foxFlipValue = 0.0;   // current (smoothed) flip value 0..1
  var _foxFlipTarget = 0.0;  // desired flip target (0 or 1)
  var _flipThreshold = 100.0; // px/s threshold to decide direction
  // reduce smoothing factor to slow the transition (more smoothing)
  var _flipSmoothing = 0.06; // 0..1 smoothing per frame (smaller = slower, smoother)

  function animateFoxFlip(){
    // simple exponential / lerp smoothing each frame
    _foxFlipValue += (_foxFlipTarget - _foxFlipValue) * _flipSmoothing;
    // push to shader as a continuous value (shader handles mix)
    sandbox.setUniform('u_foxFlip', _foxFlipValue);
    requestAnimationFrame(animateFoxFlip);
  }
  requestAnimationFrame(animateFoxFlip);
  function updateFoxSpriteSize(){
    if(!foxSprite) return;
    var w = Math.round((canvas.clientWidth || canvas.width) * foxSizeValue);
    foxSprite.style.width = w + 'px';
  }
  // Position foxSprite initial styles
  // DOM overlay removed — fox now rendered by shader only
  var texCounter = 0;
  var sandbox_content = "";
  var sandbox_title = "";
  var sandbox_author = "";
  var sandbox_thumbnail = "";

  // UI bindings for focus and blur
  var focusSlider = document.getElementById('focusSlider');
  var maxBlurSlider = document.getElementById('maxBlurSlider');

  /* Texture Set 功能暫時註解掉；如需恢復方便，可以移除這個區塊的註解。
  // Texture set selector
  var textureSetSelect = document.getElementById('textureSetSelect');
  var textureSetNote = document.getElementById('textureSetNote');
  // Read initial textures from canvas `data-textures`
  var initialTextures = (canvas.getAttribute('data-textures') || '').split(',').filter(function(t){ return t !== ''; });
  // Prepare two sets: default second set is a copy of the first (replace when you upload new images)
  var textureSets = [];
  textureSets[0] = initialTextures.slice();
  textureSets[1] = initialTextures.slice();

  function applyTextureSet(idx){
    idx = parseInt(idx) || 0;
    var list = textureSets[idx] || textureSets[0];
    for(var i=0;i<list.length;i++){
      sandbox.setUniform('u_tex'+i, list[i]);
    }
    // keep data-textures attribute in sync
    canvas.setAttribute('data-textures', list.join(','));
    textureSetNote.textContent = 'Using Set ' + (idx+1);
    // ensure other uniforms stay applied
    updateUniforms();
  }

  textureSetSelect.addEventListener('change', function(){ applyTextureSet(this.value); });
  */

  function updateUniforms(){
    // focus: 0 = front in focus, 1 = back in focus
    sandbox.setUniform('u_focus', parseFloat(focusSlider.value));
    // max blur scale: 0..1 mapped in shader to a sensible pixel radius
    sandbox.setUniform('u_maxBlur', parseFloat(maxBlurSlider.value));
    // NOTE: 不在此覆寫 u_debug（以免開發偵錯模式被 slider 清除）
  }

  focusSlider.addEventListener('input', updateUniforms);
  maxBlurSlider.addEventListener('input', updateUniforms);
  // set initial values
  // Texture Set 功能已暫時註解；改用原始 data-textures 並套用 uniforms
  // applyTextureSet(textureSetSelect.value || 0);
  // 將 data-textures 內的貼圖載入 canvas（原本 applyTextureSet 會做的事）
  // store initial texture paths so we can restore them later
  var initialTextures = (canvas.getAttribute('data-textures') || '').split(',').filter(function(t){ return t !== ''; });
  (function loadInitialTextures(){
    // ensure array length is 6
    for(var i=initialTextures.length;i<6;i++) initialTextures.push('');
    for(var i=0;i<initialTextures.length;i++){
      if(initialTextures[i] && initialTextures[i].length>0) sandbox.setUniform('u_tex'+i, initialTextures[i]);
    }
    updateUniforms();
  })();
  // 載入「狐狸坐下」素材
  (function loadFoxSitToCanvas(){
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = 'data/fox_sit_alpha.png';
    img.onload = function(){
      var c = document.createElement('canvas');
      c.width = img.naturalWidth || img.width;
      c.height = img.naturalHeight || img.height;
      var ctx = c.getContext('2d');
      ctx.clearRect(0,0,c.width,c.height);
      ctx.drawImage(img, 0, 0, c.width, c.height);
      try{
        var imgData = ctx.getImageData(0,0,c.width,c.height);
        var d = imgData.data;
        for(var i=0;i<d.length;i+=4){
          var a = d[i+3] / 255;
          d[i] = Math.round(d[i] * a);
          d[i+1] = Math.round(d[i+1] * a);
          d[i+2] = Math.round(d[i+2] * a);
        }
        ctx.putImageData(imgData, 0, 0);
      }catch(e){ console.warn('Premultiply sit image failed:', e); }
      try{
        var dataUrl = c.toDataURL('image/png');
        sandbox.setUniform('u_foxSit', dataUrl);
        sandbox.setUniform('u_foxSitResolution', c.width, c.height);
        console.log('u_foxSit uploaded from canvas (dataURL):', c.width, 'x', c.height);
      }catch(e){
        console.warn('toDataURL failed for fox_sit:', e);
        sandbox.setUniform('u_foxSit', img);
        sandbox.setUniform('u_foxSitResolution', img.naturalWidth || img.width, img.naturalHeight || img.height);
      }
    };
    img.onerror = function(e){ console.warn('Failed to load fox_sit_alpha.png:', e); };
  })();

  // 載入「狐狸坐下服裝」素材
  (function loadFoxSitCloth(){
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = 'data/fox_sit_cloth.png';
    img.onload = function(){
      var c = document.createElement('canvas');
      c.width = img.naturalWidth || img.width;
      c.height = img.naturalHeight || img.height;
      var ctx = c.getContext('2d');
      ctx.clearRect(0,0,c.width,c.height);
      ctx.drawImage(img, 0, 0, c.width, c.height);
      try{
        var imgData = ctx.getImageData(0,0,c.width,c.height);
        var d = imgData.data;
        for(var i=0;i<d.length;i+=4){
          var a = d[i+3] / 255;
          d[i] = Math.round(d[i] * a);
          d[i+1] = Math.round(d[i+1] * a);
          d[i+2] = Math.round(d[i+2] * a);
        }
        ctx.putImageData(imgData, 0, 0);
      }catch(e){ console.warn('Premultiply sit cloth failed:', e); }
      try{
        var dataUrl = c.toDataURL('image/png');
        sandbox.setUniform('u_foxSitCloth', dataUrl);
        console.log('u_foxSitCloth uploaded from canvas (dataURL):', c.width, 'x', c.height);
      }catch(e){
        console.warn('toDataURL failed for fox_sit_cloth:', e);
        sandbox.setUniform('u_foxSitCloth', img);
      }
    };
    img.onerror = function(e){ console.warn('Failed to load fox_sit_cloth.png:', e); };
  })();

  // ===== 场景贴图替换支援 (maintenance area) =====
  // 這段會在 UI `#textureList` 中建立 u_tex0..u_tex5 的顯示與上傳控制，
  // 方便直接替換場景層次圖片。也會在替換後同步更新 canvas 的 `data-textures` 屬性。
    (function setupTextureReplaceUI(){
    var container = document.getElementById('textureList');
    if(!container) return;
    // currentTextures holds the active sources (dataURLs or paths)
    var currentTextures = initialTextures.slice();
    for(var i=currentTextures.length;i<6;i++) currentTextures.push('');
    for(var i=0;i<6;i++){
      (function(idx){
        var row = document.createElement('div');
        // 每列改為垂直排列，第一行放 label+上傳，第二行放「還原」按鈕，避免右側溢出
        row.style.display = 'flex';
        row.style.flexDirection = 'column';
        row.style.gap = '6px';
        row.style.border = '1px solid rgba(0,0,0,0.06)';
        row.style.borderRadius = '6px';
        row.style.padding = '8px';

        // 第一行：label + 還原按鈕（避免換行），第二行：上傳欄位
        var topRow = document.createElement('div');
        topRow.style.display = 'flex';
        topRow.style.alignItems = 'center';
        topRow.style.gap = '8px';
        topRow.style.justifyContent = 'space-between';

        var label = document.createElement('div');
        label.style.flex = '0 0 auto';
        label.style.fontSize = '13px';
        label.style.color = '#2b231f';
        // 簡化顯示：僅顯示 layer 名稱，避免路徑太長造成雜亂
        label.textContent = 'layer' + idx;
        label.id = 'texLabel' + idx;

        var fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.id = 'texFile' + idx;
        fileInput.style.fontSize = '12px';
        fileInput.style.width = '100%';

        // 第二行：僅放置「還原」按鈕靠左，避免超出右側
        var bottomRow = document.createElement('div');
        bottomRow.style.display = 'flex';
        bottomRow.style.justifyContent = 'flex-start';

        var resetBtn = document.createElement('button');
        resetBtn.textContent = '還原';
        resetBtn.style.fontSize = '12px';
        resetBtn.title = '還原此圖層為預設來源';
        resetBtn.style.padding = '4px 8px';

        fileInput.addEventListener('change', function(e){
          var f = this.files && this.files[0];
          if(!f) return;
          var reader = new FileReader();
          reader.onload = function(ev){
            var dataUrl = ev.target.result;
            // set as texture uniform and update label + data-textures
            sandbox.setUniform('u_tex' + idx, dataUrl);
            currentTextures[idx] = dataUrl;
            canvas.setAttribute('data-textures', currentTextures.join(','));
            var lab = document.getElementById('texLabel' + idx);
            if(lab) lab.textContent = 'layer' + idx;
            console.log('Replaced u_tex' + idx + ' with uploaded file:', f.name);
          };
          reader.readAsDataURL(f);
        });

        resetBtn.addEventListener('click', function(){
          var orig = initialTextures[idx] || '';
          currentTextures[idx] = orig;
          if(orig && orig.length>0){
            sandbox.setUniform('u_tex' + idx, orig);
          } else {
            // clear by setting an empty texture (no-op for GlslCanvas, but keep state)
            // (optional) could set a 1x1 transparent dataURL here
          }
          canvas.setAttribute('data-textures', currentTextures.join(','));
          var lab = document.getElementById('texLabel' + idx);
          if(lab) lab.textContent = 'layer' + idx;
          console.log('Restored u_tex' + idx + ' to initial source');
        });

        topRow.appendChild(label);
        topRow.appendChild(resetBtn);
        bottomRow.appendChild(fileInput);
        row.appendChild(topRow);
        row.appendChild(bottomRow);
        container.appendChild(row);
      })(i);
    }
  })();

  // 載入狐狸素材並設定預設大小（放在最前景）
  // 直接使用 image 路徑可能會在上傳到 GL 時遇到 premultiplied-alpha 行為，
  // 因此這裡改為先把圖畫到離屏 canvas，再以 canvas 作為 texture 上傳。
  (function loadFoxToCanvas(){
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = 'data/fox_alpha.png';
    img.onload = function(){
      var c = document.createElement('canvas');
      c.width = img.naturalWidth || img.width;
      c.height = img.naturalHeight || img.height;
      var ctx = c.getContext('2d');
      ctx.clearRect(0,0,c.width,c.height);
      // draw the image as-is (preserve alpha) into the canvas
      ctx.drawImage(img, 0, 0, c.width, c.height);
      try{
        // Premultiply RGB by alpha on the canvas to remove white/colour fringing
        try{
          var imgData = ctx.getImageData(0,0,c.width,c.height);
          var d = imgData.data;
          for(var i=0;i<d.length;i+=4){
            var a = d[i+3] / 255;
            d[i] = Math.round(d[i] * a);
            d[i+1] = Math.round(d[i+1] * a);
            d[i+2] = Math.round(d[i+2] * a);
          }
          ctx.putImageData(imgData, 0, 0);
        }catch(e){
          // if getImageData is blocked by CORS, ignore and continue (we still upload the canvas)
          console.warn('Unable to premultiply image pixels (CORS):', e);
        }
      }catch(e){
        console.warn('Premultiply step failed:', e);
      }
      try{
        // Use dataURL string to avoid passing complex DOM objects into GlslCanvas
        // (some implementations may try to parse objects and recurse).
        var dataUrl = c.toDataURL('image/png');
        sandbox.setUniform('u_fox', dataUrl);
        console.log('u_fox uploaded from canvas (dataURL):', c.width, 'x', c.height);
        // also provide texture resolution to shader so we can preserve aspect ratio
        sandbox.setUniform('u_foxResolution', c.width, c.height);
      }catch(e){
        // Fallback: if toDataURL fails (cross-origin / security), fall back to image element
        console.warn('toDataURL failed, falling back to image element:', e);
        sandbox.setUniform('u_fox', img);
        sandbox.setUniform('u_foxResolution', img.naturalWidth || img.width, img.naturalHeight || img.height);
      }
    };
    img.onerror = function(e){
      console.warn('Failed to load fox image, falling back to direct path', e);
      sandbox.setUniform('u_fox', 'data/fox_alpha.png');
    };
  })();
  // u_foxSize 為狐狸佔畫布寬度比例（如 0.12 => 12% 畫布寬度）
  // u_foxSize 初始值設為 slider 的最小值 0.2 (20% 寬度)
  sandbox.setUniform('u_foxSize', 0.2);
  // 初始狐狸所在圖層（0 = 最前；5 = 最後）
  var foxLayer = 0;
  sandbox.setUniform('u_foxLayer', foxLayer);
  // base size (from slider) before per-layer scaling
  var baseFoxSize = 0.2;
  // fox overlay toggle: 1 = overlay on (draw fox after all layers), 0 = respect u_foxLayer
  var foxOverlayToggle = document.getElementById('foxOverlayToggle');
  sandbox.setUniform('u_foxOverlay', foxOverlayToggle && foxOverlayToggle.checked ? 1.0 : 0.0);
  if(foxOverlayToggle){
    foxOverlayToggle.addEventListener('change', function(){ sandbox.setUniform('u_foxOverlay', this.checked ? 1.0 : 0.0); });
  }

  // 偽裝服 (cloth) support: 初始為關閉
  sandbox.setUniform('u_foxClothEnabled', 0.0);
  var foxClothLoaded = false;
  var foxClothSource = null; // store dataURL or source string

  function loadClothFromImageElement(img){
    var c = document.createElement('canvas');
    c.width = img.naturalWidth || img.width;
    c.height = img.naturalHeight || img.height;
    var ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.drawImage(img, 0, 0, c.width, c.height);
    try{
      try{
        var imgData = ctx.getImageData(0,0,c.width,c.height);
        var d = imgData.data;
        for(var i=0;i<d.length;i+=4){
          var a = d[i+3] / 255;
          d[i] = Math.round(d[i] * a);
          d[i+1] = Math.round(d[i+1] * a);
          d[i+2] = Math.round(d[i+2] * a);
        }
        ctx.putImageData(imgData, 0, 0);
      }catch(e){
        console.warn('Unable to premultiply cloth image pixels (CORS or security):', e);
      }
      var dataUrl = c.toDataURL('image/png');
      sandbox.setUniform('u_foxCloth', dataUrl);
      sandbox.setUniform('u_foxClothEnabled', 1.0);
      foxClothLoaded = true;
      foxClothSource = dataUrl;
      console.log('u_foxCloth uploaded from canvas (dataURL):', c.width, 'x', c.height);
    }catch(e){
      console.warn('toDataURL failed for cloth, falling back to image element:', e);
      // fallback: set the image element or path directly
      try{
        sandbox.setUniform('u_foxCloth', img);
        sandbox.setUniform('u_foxClothEnabled', 1.0);
        foxClothLoaded = true;
        foxClothSource = img.src;
      }catch(e2){
        console.error('Failed to set cloth texture:', e2);
      }
    }
  }

  // UI elements for cloth
  var foxClothToggle = document.getElementById('foxClothToggle');
  var foxClothUpload = document.getElementById('foxClothUpload');
  var foxClothLoadDefault = document.getElementById('foxClothLoadDefault');

  if(foxClothToggle){
    foxClothToggle.addEventListener('change', function(){
      if(this.checked){
        // enable: if not loaded yet, load default cloth first
        if(!foxClothLoaded){
          // load default cloth then enable when ready
          var img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = 'data/fox_cloth.png';
          img.onload = function(){ loadClothFromImageElement(img); };
          img.onerror = function(e){
            console.warn('Failed to load default cloth image:', e);
            // still set enabled flag to attempt rendering (may be no texture)
            sandbox.setUniform('u_foxClothEnabled', 1.0);
          };
        }else{
          sandbox.setUniform('u_foxClothEnabled', 1.0);
        }
      }else{
        sandbox.setUniform('u_foxClothEnabled', 0.0);
      }
    });
  }

  if(foxClothUpload){
    foxClothUpload.addEventListener('change', function(e){
      var f = this.files && this.files[0];
      if(!f) return;
      var reader = new FileReader();
      reader.onload = function(ev){
        var dataUrl = ev.target.result;
        var img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function(){
          loadClothFromImageElement(img);
          // if toggle is checked, ensure enabled
          if(foxClothToggle && foxClothToggle.checked){ sandbox.setUniform('u_foxClothEnabled', 1.0); }
        };
        img.onerror = function(err){ console.warn('Failed to create image from uploaded file:', err); };
        img.src = dataUrl;
      };
      reader.readAsDataURL(f);
    });
  }

  if(foxClothLoadDefault){
    foxClothLoadDefault.addEventListener('click', function(){
      var img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = 'data/fox_cloth.png';
      img.onload = function(){
        loadClothFromImageElement(img);
        if(foxClothToggle) foxClothToggle.checked = true;
      };
      img.onerror = function(e){ console.warn('Failed to load default cloth image:', e); };
    });
  }

  // Layer controls UI
  var foxLayerBackBtn = document.getElementById('foxLayerBackBtn');
  var foxLayerForwardBtn = document.getElementById('foxLayerForwardBtn');
  var foxLayerLabel = document.getElementById('foxLayerLabel');
  if(foxLayerLabel) foxLayerLabel.textContent = String(foxLayer);

  // Safety: prevent extremely fast repeated layer changes
  var _layerChangeLocked = false;
  function _withLayerCooldown(fn){
    if(_layerChangeLocked) return;
    _layerChangeLocked = true;
    try{ fn(); }finally{
      setTimeout(function(){ _layerChangeLocked = false; }, 140);
    }
  }

  function setFoxLayer(newLayer){
    // clamp to valid range 0..5
    var v = Math.max(0, Math.min(5, Math.floor(newLayer)));
    foxLayer = v;
    sandbox.setUniform('u_foxLayer', foxLayer);
    if(foxLayerLabel) foxLayerLabel.textContent = String(foxLayer);
    // apply per-layer scale: shrink by 15% each layer moved back (multiplicative)
    var scaled = baseFoxSize * Math.pow(0.85, foxLayer);
    sandbox.setUniform('u_foxSize', scaled);
  }

  function moveFoxBack(){
    _withLayerCooldown(function(){
      // if overlay was on, disable it so layer changes take effect
      if(foxOverlayToggle && foxOverlayToggle.checked){
        foxOverlayToggle.checked = false;
        sandbox.setUniform('u_foxOverlay', 0.0);
      }
      setFoxLayer(foxLayer + 1);
    });
  }

  function moveFoxForward(){
    _withLayerCooldown(function(){
      if(foxOverlayToggle && foxOverlayToggle.checked){
        foxOverlayToggle.checked = false;
        sandbox.setUniform('u_foxOverlay', 0.0);
      }
      setFoxLayer(foxLayer - 1);
    });
  }

  if(foxLayerBackBtn) foxLayerBackBtn.addEventListener('click', moveFoxBack);
  if(foxLayerForwardBtn) foxLayerForwardBtn.addEventListener('click', moveFoxForward);

  // Keyboard shortcuts: ArrowLeft => move forward (towards front), ArrowRight => move back
  window.addEventListener('keydown', function(e){
    // ignore when typing in inputs/textareas or contenteditable
    var ae = document.activeElement;
    if(ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;
    if(e.key === 'ArrowLeft'){
      e.preventDefault();
      moveFoxForward();
    } else if(e.key === 'ArrowRight'){
      e.preventDefault();
      moveFoxBack();
    } else if(e.key === 'ArrowDown'){
      e.preventDefault();
      foxMode = 1;
      horizontalEnabled = false;
      movementEnabled = false;
      // 建立坐下錨點為最後已知位置
      sitAnchorX = (_lastSetMouseX !== null) ? _lastSetMouseX : _prevMouseX;
      sitAnchorY = (_lastSetMouseY !== null) ? _lastSetMouseY : _prevMouseY;
      // 記錄背景 UV 錨點
      sitAnchorUVx = (sitAnchorX !== null && canvas.width) ? (sitAnchorX / canvas.width) : null;
      sitAnchorUVy = (sitAnchorY !== null && canvas.height) ? (sitAnchorY / canvas.height) : null;
      // 暫時移除滑鼠事件，避免外部更新影響
      canvas.removeEventListener('mousemove', updateMouseUniform);
      // 阻擋事件傳遞給 GlslCanvas 內建滑鼠更新（捕獲階段攔截）
      if(!window.__blockersInstalled){
        window.__blockersInstalled = true;
        window.__blockMouseMove = function(ev){ ev.stopImmediatePropagation(); ev.stopPropagation(); ev.preventDefault(); };
        window.__blockPointerMove = function(ev){ ev.stopImmediatePropagation(); ev.stopPropagation(); ev.preventDefault(); };
        window.__blockTouchMove = function(ev){ ev.stopImmediatePropagation(); ev.stopPropagation(); ev.preventDefault(); };
      }
      canvas.addEventListener('mousemove', window.__blockMouseMove, true);
      canvas.addEventListener('pointermove', window.__blockPointerMove, true);
      canvas.addEventListener('touchmove', window.__blockTouchMove, { capture: true, passive: false });
      sandbox.setUniform('u_foxMode', foxMode);
    // 全局安裝事件阻擋，避免 GlslCanvas 內建更新 u_mouse 造成「貼齊」而非阻尼
    (function installGlobalBlockers(){
      if(!window.__blockersInstalled){
        window.__blockersInstalled = true;
        // 僅在事件座標落在 canvas 範圍內時阻擋（捕獲階段），避免影響整頁其他互動
        window.__blockMouseMove = function(ev){
          var rect = canvas.getBoundingClientRect();
          var inside = ev.clientX >= rect.left && ev.clientX <= rect.right && ev.clientY >= rect.top && ev.clientY <= rect.bottom;
          if(inside){ ev.stopImmediatePropagation(); ev.stopPropagation(); ev.preventDefault(); }
        };
        window.__blockPointerMove = function(ev){
          var rect = canvas.getBoundingClientRect();
          var inside = ev.clientX >= rect.left && ev.clientX <= rect.right && ev.clientY >= rect.top && ev.clientY <= rect.bottom;
          if(inside){ ev.stopImmediatePropagation(); ev.stopPropagation(); ev.preventDefault(); }
        };
        window.__blockTouchMove = function(ev){
          var rect = canvas.getBoundingClientRect();
          var touches = ev.touches && ev.touches.length ? Array.from(ev.touches) : [];
          var inside = touches.some(function(t){ return t.clientX >= rect.left && t.clientX <= rect.right && t.clientY >= rect.top && t.clientY <= rect.bottom; });
          if(inside){ ev.stopImmediatePropagation(); ev.stopPropagation(); ev.preventDefault(); }
        };
        // 在 window 捕獲階段攔截，確保先於 GlslCanvas
        window.addEventListener('mousemove', window.__blockMouseMove, true);
        window.addEventListener('pointermove', window.__blockPointerMove, true);
        window.addEventListener('touchmove', window.__blockTouchMove, { capture: true, passive: false });
      }
    })();
    } else if(e.key === 'ArrowUp'){
      e.preventDefault();
      foxMode = 0;
      horizontalEnabled = true;
      movementEnabled = true;
      sitAnchorX = null; sitAnchorY = null;
      sitAnchorUVx = null; sitAnchorUVy = null;
      // 恢復滑鼠事件
      canvas.addEventListener('mousemove', updateMouseUniform);
      // 解除事件阻擋，恢復 GlslCanvas 內建滑鼠更新
      if(window.__blockersInstalled){
        canvas.removeEventListener('mousemove', window.__blockMouseMove, true);
        canvas.removeEventListener('pointermove', window.__blockPointerMove, true);
        canvas.removeEventListener('touchmove', window.__blockTouchMove, { capture: true });
      }
      sandbox.setUniform('u_foxMode', foxMode);
    }
  });

  // 點擊 canvas 左鍵讓狐狸往後一層（towards background）移動，超過最後一層則回到最前
  // 目前為了 Debug 穩定性暫時停用點擊切換圖層功能：
  /*
  canvas.addEventListener('mousedown', function(e){
    if(e.button === 0){
      foxLayer = (foxLayer + 1) % 6; // 0..5
      sandbox.setUniform('u_foxLayer', foxLayer);
    }
  });
  */

  // Fox size slider wiring
  var foxSizeSlider = document.getElementById('foxSizeSlider');
  var foxSizeLabel = document.getElementById('foxSizeLabel');
  if(foxSizeSlider){
    // set initial value and uniform
    var initialFoxSize = parseFloat(foxSizeSlider.value);
    // base size (before per-layer scaling)
    baseFoxSize = initialFoxSize;
    // apply per-layer scaling for current layer
    var initialScaled = baseFoxSize * Math.pow(0.70, foxLayer);
    sandbox.setUniform('u_foxSize', initialScaled);
    // map slider range [min..max] -> display 1..100%
    var fsMin = parseFloat(foxSizeSlider.min);
    var fsMax = parseFloat(foxSizeSlider.max);
    var displayPct = Math.round(((initialFoxSize - fsMin) / (fsMax - fsMin)) * 99.0 + 1.0);
    if(foxSizeLabel) foxSizeLabel.textContent = displayPct + '%';
    foxSizeSlider.addEventListener('input', function(){
      var v = parseFloat(this.value);
      // update base size and recompute scaled size according to current layer
      baseFoxSize = v;
      var scaled = baseFoxSize * Math.pow(0.70, foxLayer);
      sandbox.setUniform('u_foxSize', scaled);
      var fsMin = parseFloat(this.min);
      var fsMax = parseFloat(this.max);
      var displayPct = Math.round(((v - fsMin) / (fsMax - fsMin)) * 99.0 + 1.0);
      if(foxSizeLabel) foxSizeLabel.textContent = displayPct + '%';
    });
  }
  // Fox feather slider wiring
  // Fox feather fixed to 20px (slider removed)
  sandbox.setUniform('u_foxFeather', 20.0);

  // 狐狸模式：0=站立(可左右移動)、1=坐下(不可左右移動)
  var foxMode = 0;
  var horizontalEnabled = true;
  // 坐下時固定位置（不隨滑鼠），站立時恢復移動
  var movementEnabled = true;
  var sitAnchorX = null, sitAnchorY = null;
  // 以背景貼圖座標（UV 0..1）作為坐下錨點
  var sitAnchorUVx = null, sitAnchorUVy = null;
  sandbox.setUniform('u_foxMode', foxMode);

  // 漸進式跟隨：目標滑鼠座標（像素）與目前跟隨座標（像素）
  var _targetMouseX = null, _targetMouseY = null;
  var _followMouseX = null, _followMouseY = null;
  // 速度＋阻尼模型參數（臨界阻尼彈簧）
  var _velX = 0.0, _velY = 0.0;
  var _stiffness = 12.0;  // k：越大越快接近目標
  var _damping = 2.0 * Math.sqrt(_stiffness); // c：臨界阻尼（c = 2*sqrt(k)）
  var _maxSpeed = 1600;   // 限制最大速度避免振盪過快

  // 偵測 u_fox texture 是否有正確載入，並在載入完成時回報到 console（不要自動關閉偵錯）
  setTimeout(function(){
    console.log('GlslCanvas textures snapshot:', Object.keys(sandbox.textures || {}));
    var foxTex = sandbox.textures && sandbox.textures['u_fox'];
    if(foxTex){
      foxTex.on('loaded', function(){
        console.log('u_fox loaded:', foxTex.width, 'x', foxTex.height, 'src=', foxTex.source);
      });
      if(foxTex.width && foxTex.height){
        console.log('u_fox already loaded:', foxTex.width, 'x', foxTex.height, 'src=', foxTex.source);
      }
    } else {
      console.warn('u_fox texture not found in sandbox.textures');
    }
    // 不主動改變偵錯模式，由 UI 控制
    // 在 console 顯示目前 u_mouse（pixel）以便確認
    try{ console.log('initial u_mouse (px):', canvas.width/2, canvas.height/2); }catch(e){}
  }, 200);

  // 確保 shader 能接收到滑鼠座標：手動在 JS 層傳入 u_mouse（像素空間），
  // 因為 GlslCanvas 只有在 shader 中出現多次 u_mouse 時才會自動更新。
  // 包裝 setMouse 以記錄最後設定的座標，供坐下錨點使用
  var _lastSetMouseX = null, _lastSetMouseY = null;
  function setMouse(x,y){ sandbox.setUniform('u_mouseCustom', x, y); _lastSetMouseX = x; _lastSetMouseY = y; }
  // 坐下時每幀強制錨定位置，避免任何外部更新造成位移
  function enforceSitAnchor(){
    if(!movementEnabled){
      var ax = (sitAnchorUVx !== null) ? (sitAnchorUVx * canvas.width) : (sitAnchorX !== null ? sitAnchorX : (_lastSetMouseX !== null ? _lastSetMouseX : canvas.width*0.5));
      var ay = (sitAnchorUVy !== null) ? (sitAnchorUVy * canvas.height) : (sitAnchorY !== null ? sitAnchorY : (_lastSetMouseY !== null ? _lastSetMouseY : canvas.height*0.5));
      setMouse(ax, ay);
    }
    requestAnimationFrame(enforceSitAnchor);
  }
  requestAnimationFrame(enforceSitAnchor);
  // 站立模式下的漸進式跟隨更新：每幀把 _followMouse 向 _targetMouse 逼近
  function updateFollow(){
    var now = (window.performance && performance.now) ? performance.now() : Date.now();
    if(window.__lastFollowTime === undefined) window.__lastFollowTime = now;
    var dt = Math.min(0.05, Math.max(0.001, (now - window.__lastFollowTime) / 1000.0)); // 秒，限制步長
    window.__lastFollowTime = now;
    if(movementEnabled){
      if(_targetMouseX === null || _targetMouseY === null){
        // 尚未有目標，維持現況
      } else {
        if(_followMouseX === null || _followMouseY === null){
          // 初始化跟隨位置在目前 shader 的 u_mouse
          _followMouseX = (_lastSetMouseX !== null) ? _lastSetMouseX : _targetMouseX;
          _followMouseY = (_lastSetMouseY !== null) ? _lastSetMouseY : _targetMouseY;
        }
        // 彈簧力：F = -k * x - c * v（臨界阻尼），x 為偏差，v 為速度
        var dx = _targetMouseX - _followMouseX;
        var dy = _targetMouseY - _followMouseY;
        var ax = _stiffness * dx - _damping * _velX;
        var ay = _stiffness * dy - _damping * _velY;
        // 穩定積分（半顯式 Euler）
        _velX += ax * dt;
        _velY += ay * dt;
        // 速度限制避免過快
        var speed = Math.hypot(_velX, _velY);
        if(speed > _maxSpeed){
          var r = _maxSpeed / (speed || 1);
          _velX *= r; _velY *= r;
        }
        // 水平禁用時不更新 X 速度與位置
        if(horizontalEnabled){
          _followMouseX += _velX * dt;
        } else {
          _velX = 0.0; // 清空水平速度
        }
        _followMouseY += _velY * dt;
        setMouse(_followMouseX, _followMouseY);
      }
    }
    requestAnimationFrame(updateFollow);
  }
  requestAnimationFrame(updateFollow);
  function updateMouseUniform(e){
    var rect = canvas.getBoundingClientRect();
    // Map CSS mouse coordinates to the canvas drawing buffer pixel coordinates
    // canvas.width/height are the actual drawingbuffer sizes (may be scaled by DPR)
    var cssX = e.clientX - rect.left;
    var cssY = e.clientY - rect.top;
    var scaleX = canvas.width / rect.width;
    var scaleY = canvas.height / rect.height;
    // 以 canvas 座標為基準（背景 UV 對齊）：X 從左到右線性，Y 從下到上
    var mx = cssX * scaleX;
    var my = (rect.bottom - e.clientY) * scaleY;
    if(movementEnabled){
      // 站立模式：只更新目標座標，實際座標由 updateFollow() 漸進逼近
      _targetMouseX = mx;
      _targetMouseY = my;
      // 若水平禁用，保留目標 X 為當前跟隨 X（不改變水平目標）
      if(!horizontalEnabled && _followMouseX !== null){
        _targetMouseX = _followMouseX;
      }
    } else {
      // 坐下：位置固定在切換時的錨點（以背景 UV 基準）
      var ax = (sitAnchorUVx !== null) ? (sitAnchorUVx * canvas.width) : ((sitAnchorX === null) ? (_lastSetMouseX !== null ? _lastSetMouseX : (_prevMouseX === null ? mx : _prevMouseX)) : sitAnchorX);
      var ay = (sitAnchorUVy !== null) ? (sitAnchorUVy * canvas.height) : ((sitAnchorY === null) ? (_lastSetMouseY !== null ? _lastSetMouseY : my) : sitAnchorY);
      setMouse(ax, ay);
      // 坐下時不更新前次狀態與速度，直接返回
      return;
    }
    // compute horizontal velocity (px/s) and update flip target accordingly
    var now = (window.performance && performance.now) ? performance.now() : Date.now();
    if(_prevMouseX === null || _prevTime === null){
      _prevMouseX = mx;
      _prevMouseY = my;
      _prevTime = now;
    }
    var dt = Math.max(1.0, now - _prevTime); // ms
    var vx = (mx - _prevMouseX) / (dt / 1000.0); // px/s
    // 更新翻轉目標：站立時依速度，坐下時固定不翻轉
    if(foxMode === 0){
      if(vx > _flipThreshold) _foxFlipTarget = 1.0;
      else if(vx < -_flipThreshold) _foxFlipTarget = 0.0;
    } else {
      // 坐下時不更新翻轉目標，維持目前方向
    }
    // remember previous for next velocity calc
    _prevMouseX = mx;
    _prevMouseY = my;
    _prevTime = now;
    // debug log for verification
    if(window.__mouseDebugCounter === undefined) window.__mouseDebugCounter = 0;
    if((window.__mouseDebugCounter++ % 50) === 0){
      console.log('u_mouse (px)=', mx.toFixed(1), my.toFixed(1), 'canvas draw size=', canvas.width, 'x', canvas.height, 'rect size=', rect.width.toFixed(1), 'x', rect.height.toFixed(1));
      console.log('u_mouseCustom (px)=', mx.toFixed(1), my.toFixed(1), 'canvas draw size=', canvas.width, 'x', canvas.height, 'rect size=', rect.width.toFixed(1), 'x', rect.height.toFixed(1));
    }
  }
  // 轉為在 window 層級監聽滑鼠移動，確保我們的邏輯先處理
  window.addEventListener('mousemove', updateMouseUniform);
  // 設定初始滑鼠位置為畫布中心
  // set initial mouse to canvas center using drawingbuffer coordinates
  (function setInitialMouse(){
    // Delay slightly to allow GlslCanvas to resize the drawingbuffer
    setTimeout(function(){
      var mx = canvas.width / 2.0;
      var my = canvas.height / 2.0;
      setMouse(mx, my);
      // set initial flip based on center (defaults to not flipped)
      var initialFlip = (mx > (canvas.width * 0.5)) ? 1.0 : 0.0;
      _foxFlipValue = initialFlip;
      _foxFlipTarget = initialFlip;
      sandbox.setUniform('u_foxFlip', initialFlip);
      // initialize prev mouse/time for velocity calc
      _prevMouseX = mx;
      _prevMouseY = my;
      _prevTime = (window.performance && performance.now) ? performance.now() : Date.now();
      // DOM fox removed; no DOM positioning necessary
      console.log('initial u_mouse (px)=', mx, my, 'canvas draw size=', canvas.width, 'x', canvas.height);
      console.log('initial u_mouseCustom (px)=', mx, my, 'canvas draw size=', canvas.width, 'x', canvas.height);
    }, 100);
  })();
  // no DOM fox overlay to synchronize

  // Position UI to be vertically centered and fixed to the canvas left edge.
  function positionUI(){
    var ui = document.getElementById('ui');
    if(!canvas || !ui) return;
    var crect = canvas.getBoundingClientRect();
    // ensure ui has been laid out to get correct size
    var uiW = ui.offsetWidth || 240;
    var uiH = ui.offsetHeight || 180;
    // place ui so its right edge is a small gap from canvas left edge
    var gap = 12;
    var left = Math.round(crect.left - uiW - gap);
    // if not enough space on left, clamp to 10px
    if(left < 10) left = 10;
    var top = Math.round(crect.top + crect.height/2 - uiH/2);
    if(top < 10) top = 10;
    // 讓側邊面板高度與 canvas 高度切齊
    ui.style.height = Math.round(crect.height) + 'px';
    ui.style.overflow = 'auto';
    ui.style.left = left + 'px';
    ui.style.top = top + 'px';
    ui.style.transform = 'none';
  }

  // reposition on load and when window resizes (or when canvas layout changes)
  window.addEventListener('load', positionUI);
  window.addEventListener('resize', function(){
    // debounce a bit
    clearTimeout(window._positionUITimeout);
    window._positionUITimeout = setTimeout(positionUI, 80);
  });
  // also reposition shortly after initial apply to account for fonts/images
  setTimeout(positionUI, 120);

  // ================= DCCU Camouflage Preview =================
  (function initDCCUPreview(){
    var dccuCanvas = document.getElementById('dccuCanvas');
    if(!dccuCanvas) return;
    var dccu = new GlslCanvas(dccuCanvas);
    // Resize drawing buffer to match CSS size and DPR
    function resizeDCCU(){
      var dpr = (window.devicePixelRatio || 1);
      var cssW = dccuCanvas.clientWidth || 360;
      var cssH = Math.round(cssW * 2.0/3.0); // keep 3:2 aspect in preview
      dccuCanvas.style.height = cssH + 'px';
      dccuCanvas.width = Math.round(cssW * dpr);
      dccuCanvas.height = Math.round(cssH * dpr);
      dccu.setUniform('u_resolution', dccuCanvas.width, dccuCanvas.height);
    }
    resizeDCCU();
    // Parameters UI
    var dccuScale = document.getElementById('dccuScale');
    // Noise Amp 已取消
    var dccuRotate = document.getElementById('dccuRotate');
    var dccuRatioD = document.getElementById('dccuRatioD');
    var dccuRatioB = document.getElementById('dccuRatioB');
    var dccuRatioC = document.getElementById('dccuRatioC');
    var dccuRatioDLabel = document.getElementById('dccuRatioDLabel');
    var dccuRatioBLabel = document.getElementById('dccuRatioBLabel');
    var dccuRatioCLabel = document.getElementById('dccuRatioCLabel');
    // Cell Size 已移除
    // Try to load reference swatch (NWU Type I) if available
    var refCandidates = ['data/NWU_Type_I_camouflage_pattern_swatch.png','data/NWU_Type_I_camouflage_pattern_swatch.jpg','data/NWU_Type_I_camouflage_pattern_swatch.jpeg'];
    (function loadRef(){
      var idx = 0;
      function tryNext(){
        if(idx >= refCandidates.length){ dccu.setUniform('u_useRef', 0.0); return; }
        var img = new Image(); img.crossOrigin = 'anonymous';
        img.onload = function(){ dccu.setUniform('u_refTex', img); dccu.setUniform('u_useRef', 1.0); };
        img.onerror = function(){ idx++; tryNext(); };
        img.src = refCandidates[idx];
      }
      tryNext();
    })();
    function applyDCCU(){
      var sc = parseFloat(dccuScale.value || '1.0');
      var rt = parseFloat(dccuRotate.value || '0.0');
      // Normalize ratios to sum <= 1.0, clamp
      var rD = Math.max(0, Math.min(1, parseFloat(dccuRatioD.value || '0.25')));
      var rB = Math.max(0, Math.min(1, parseFloat(dccuRatioB.value || '0.20')));
      var rC = Math.max(0, Math.min(1, parseFloat(dccuRatioC.value || '0.25')));
      var sum = rD + rB + rC;
      if(sum > 1.0){ rD /= sum; rB /= sum; rC /= sum; sum = 1.0; }
      var t1 = rD;          // threshold for D
      var t2 = rD + rB;     // threshold for B
      var t3 = rD + rB + rC;// threshold for C
      dccu.setUniform('u_scale', sc);
      dccu.setUniform('u_gridRotate', rt);
      dccu.setUniform('u_cellBase', 12.0);
      dccu.setUniform('u_thresh1', t1);
      dccu.setUniform('u_thresh2', t2);
      dccu.setUniform('u_thresh3', t3);
      // optional softness uniform if shader uses it later
      dccu.setUniform('u_edgeSoftness', 8.0);
      // Update percentage labels for logging/testing
      if(dccuRatioDLabel) dccuRatioDLabel.textContent = Math.round(rD*100) + '%';
      if(dccuRatioBLabel) dccuRatioBLabel.textContent = Math.round(rB*100) + '%';
      if(dccuRatioCLabel) dccuRatioCLabel.textContent = Math.round(rC*100) + '%';
    }
    // initial set
    applyDCCU();
    // bind inputs
    if(dccuScale) dccuScale.addEventListener('input', applyDCCU);
    // dccuNoise removed
    if(dccuRotate) dccuRotate.addEventListener('input', applyDCCU);
    if(dccuRatioD) dccuRatioD.addEventListener('input', applyDCCU);
    if(dccuRatioB) dccuRatioB.addEventListener('input', applyDCCU);
    if(dccuRatioC) dccuRatioC.addEventListener('input', applyDCCU);
    // dccuCellSize removed
    // simple time uniform for potential animation hooks
    function tick(){
      var t = (window.performance && performance.now) ? performance.now()/1000.0 : Date.now()/1000.0;
      dccu.setUniform('u_time', t);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
    // keep preview sized within panel on window resize
    window.addEventListener('resize', function(){
      clearTimeout(window.__dccuResizeTimer);
      window.__dccuResizeTimer = setTimeout(function(){ resizeDCCU(); applyDCCU(); }, 80);
    });
  })();
</script>

</html>