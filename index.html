<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>GlslCanvas</title>
  <script type="text/javascript"
    src="dist/GlslCanvas.js"></script>
  <style>
    /* 聶永貞風格：簡潔、留白、質感紙色與沉穩深色對比 */
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(180deg,#0b0f0e 0%, #0f1410 100%);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      color: #111;
      /* 優先使用明體系字型；若系統沒有則退至 Noto Serif TC / serif */
      font-family: "PMingLiU", "MingLiU", "Noto Serif TC", serif;
      font-size: 15px;
      line-height: 1.4;
    }

    /* 畫布靠右以騰出左側控制區 */
    #glslCanvas {
      position: absolute;
      top: 50%;
      left: 60%;
      transform: translate(-50%, -50%);
      border-radius: 10px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.6);
      background: #000;
    }

    /* 左側控制面板：紙色、陰影、留白 */
    #ui {
      position: fixed;
      /* left/top will be positioned by JS to stick to canvas left edge */
      left: auto;
      top: auto;
      transform: none;
      z-index: 11;
      background: rgba(250,246,241,0.98);
      color: #2b231f;
      padding: 16px 18px;
      border-radius: 10px;
      box-shadow: 0 8px 28px rgba(6,10,8,0.6);
      max-width: 240px;
      border: 1px solid rgba(30,30,30,0.04);
    }

    #ui label { display: block; margin-bottom: 10px; font-weight: 500; }
    #ui .small { font-size: 12px; color: #7a6f67; margin-top: 4px; }

    /* select 樣式 */
    #textureSetSelect {
      width: 100%;
      padding: 8px 10px;
      font-family: inherit;
      background: #fff;
      color: #2b231f; /* 深色文字，增加可讀性 */
      border: 1px solid rgba(40,40,40,0.06);
      border-radius: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }

    /* range (slider) 基本樣式 */
    input[type=range] {
      width: 100%;
      margin-top: 6px;
      background: transparent;
    }
    input[type=range]::-webkit-slider-runnable-track {
      height: 8px;
      background: linear-gradient(90deg,#e9dacf,#d8c9bd);
      border-radius: 6px;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      margin-top: -5px;
      background: #2b231f;
      border-radius: 50%;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
      border: 2px solid #fff3ec;
    }
    input[type=range]::-moz-range-track {
      height: 8px;
      background: linear-gradient(90deg,#e9dacf,#d8c9bd);
      border-radius: 6px;
    }
    input[type=range]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #2b231f;
      border-radius: 50%;
      border: 2px solid #fff3ec;
    }

    /* 小字說明 */
    #textureSetNote { font-size: 12px; color: #6d625b; margin-top:6px; }

    /* 調整 label 與控制元件間距 */
    #ui > div { margin-bottom: 12px; }
  </style>
</head>

<body>
  <canvas id="glslCanvas" data-fragment-url="shader/environment_v1.frag" width="900" height="600"
    data-textures="data/0_Top%20Canopy%20Leaves_alpha.png,data/1_Foreground_alpha.png,data/2_Mid-Foreground_alpha.png,data/3_Midground_alpha.png,data/4_Back-Midground_alpha.png,data/5_Background.png"></canvas>

  <!-- UI: focus & max blur sliders -->
  <div id="ui">
    <div style="margin-bottom:8px">
      <label>焦距: <input id="focusSlider" type="range" min="0" max="1" step="0.01" value="0.0"></label>
    </div>
    <!-- Texture Set selector 暫時註解，不顯示也不執行；如需恢復，移除下方註解即可 -->
    <!--
    <div style="margin-bottom:8px">
      <label>Texture Set: 
        <select id="textureSetSelect">
          <option value="0">Set 1</option>
          <option value="1">Set 2</option>
        </select>
      </label>
      <div style="font-size:12px;color:#ccc" id="textureSetNote">Using Set 1</div>
    </div>
    -->
    <div>
      <label>光圈: <input id="maxBlurSlider" type="range" min="0" max="1" step="0.01" value="0.5"></label>
    </div>
    <div style="margin-top:8px">
      <label>Fox Size: <input id="foxSizeSlider" type="range" min="0.2" max="1.0" step="0.01" value="0.2"></label>
      <div class="small">狐狸尺寸: <span id="foxSizeLabel">1%</span></div>
    </div>
    <div style="margin-top:8px">
      <!-- Fox Feather slider removed; fixed feather value enforced in JS -->
  
    </div>
    <div style="margin-top:8px">
      <label style="display:flex;align-items:center;gap:8px"><input id="foxOverlayToggle" type="checkbox" checked> <span style="font-weight:500">Fox Overlay</span></label>
      <div class="small">若勾選，狐狸會以 overlay 方式渲染於最前方，確保可見。</div>
      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <button id="foxLayerBackBtn" title="向後一層">向後</button>
        <button id="foxLayerForwardBtn" title="向前一層">向前</button>
        <div class="small" style="margin-left:6px">目前圖層: <span id="foxLayerLabel">0</span></div>
      </div>
    </div>
  </div>
</body>
<script>
  var canvas = document.getElementById("glslCanvas");
  var sandbox = new GlslCanvas(canvas);
  // Mouse-movement flip state (velocity-driven, smoothed)
  var _prevMouseX = null;
  var _prevTime = null;
  var _foxFlipValue = 0.0;   // current (smoothed) flip value 0..1
  var _foxFlipTarget = 0.0;  // desired flip target (0 or 1)
  var _flipThreshold = 100.0; // px/s threshold to decide direction
  // reduce smoothing factor to slow the transition (more smoothing)
  var _flipSmoothing = 0.06; // 0..1 smoothing per frame (smaller = slower, smoother)

  function animateFoxFlip(){
    // simple exponential / lerp smoothing each frame
    _foxFlipValue += (_foxFlipTarget - _foxFlipValue) * _flipSmoothing;
    // push to shader as a continuous value (shader handles mix)
    sandbox.setUniform('u_foxFlip', _foxFlipValue);
    requestAnimationFrame(animateFoxFlip);
  }
  requestAnimationFrame(animateFoxFlip);
  function updateFoxSpriteSize(){
    if(!foxSprite) return;
    var w = Math.round((canvas.clientWidth || canvas.width) * foxSizeValue);
    foxSprite.style.width = w + 'px';
  }
  // Position foxSprite initial styles
  // DOM overlay removed — fox now rendered by shader only
  var texCounter = 0;
  var sandbox_content = "";
  var sandbox_title = "";
  var sandbox_author = "";
  var sandbox_thumbnail = "";

  // UI bindings for focus and blur
  var focusSlider = document.getElementById('focusSlider');
  var maxBlurSlider = document.getElementById('maxBlurSlider');

  /* Texture Set 功能暫時註解掉；如需恢復方便，可以移除這個區塊的註解。
  // Texture set selector
  var textureSetSelect = document.getElementById('textureSetSelect');
  var textureSetNote = document.getElementById('textureSetNote');
  // Read initial textures from canvas `data-textures`
  var initialTextures = (canvas.getAttribute('data-textures') || '').split(',').filter(function(t){ return t !== ''; });
  // Prepare two sets: default second set is a copy of the first (replace when you upload new images)
  var textureSets = [];
  textureSets[0] = initialTextures.slice();
  textureSets[1] = initialTextures.slice();

  function applyTextureSet(idx){
    idx = parseInt(idx) || 0;
    var list = textureSets[idx] || textureSets[0];
    for(var i=0;i<list.length;i++){
      sandbox.setUniform('u_tex'+i, list[i]);
    }
    // keep data-textures attribute in sync
    canvas.setAttribute('data-textures', list.join(','));
    textureSetNote.textContent = 'Using Set ' + (idx+1);
    // ensure other uniforms stay applied
    updateUniforms();
  }

  textureSetSelect.addEventListener('change', function(){ applyTextureSet(this.value); });
  */

  function updateUniforms(){
    // focus: 0 = front in focus, 1 = back in focus
    sandbox.setUniform('u_focus', parseFloat(focusSlider.value));
    // max blur scale: 0..1 mapped in shader to a sensible pixel radius
    sandbox.setUniform('u_maxBlur', parseFloat(maxBlurSlider.value));
    // NOTE: 不在此覆寫 u_debug（以免開發偵錯模式被 slider 清除）
  }

  focusSlider.addEventListener('input', updateUniforms);
  maxBlurSlider.addEventListener('input', updateUniforms);
  // set initial values
  // Texture Set 功能已暫時註解；改用原始 data-textures 並套用 uniforms
  // applyTextureSet(textureSetSelect.value || 0);
  // 將 data-textures 內的貼圖載入 canvas（原本 applyTextureSet 會做的事）
  (function loadInitialTextures(){
    var list = (canvas.getAttribute('data-textures') || '').split(',').filter(function(t){ return t !== ''; });
    for(var i=0;i<list.length;i++){
      sandbox.setUniform('u_tex'+i, list[i]);
    }
    updateUniforms();
  })();

  // 載入狐狸素材並設定預設大小（放在最前景）
  // 直接使用 image 路徑可能會在上傳到 GL 時遇到 premultiplied-alpha 行為，
  // 因此這裡改為先把圖畫到離屏 canvas，再以 canvas 作為 texture 上傳。
  (function loadFoxToCanvas(){
    var img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = 'data/fox_alpha.png';
    img.onload = function(){
      var c = document.createElement('canvas');
      c.width = img.naturalWidth || img.width;
      c.height = img.naturalHeight || img.height;
      var ctx = c.getContext('2d');
      ctx.clearRect(0,0,c.width,c.height);
      // draw the image as-is (preserve alpha) into the canvas
      ctx.drawImage(img, 0, 0, c.width, c.height);
      try{
        // Premultiply RGB by alpha on the canvas to remove white/colour fringing
        try{
          var imgData = ctx.getImageData(0,0,c.width,c.height);
          var d = imgData.data;
          for(var i=0;i<d.length;i+=4){
            var a = d[i+3] / 255;
            d[i] = Math.round(d[i] * a);
            d[i+1] = Math.round(d[i+1] * a);
            d[i+2] = Math.round(d[i+2] * a);
          }
          ctx.putImageData(imgData, 0, 0);
        }catch(e){
          // if getImageData is blocked by CORS, ignore and continue (we still upload the canvas)
          console.warn('Unable to premultiply image pixels (CORS):', e);
        }
      }catch(e){
        console.warn('Premultiply step failed:', e);
      }
      try{
        // Use dataURL string to avoid passing complex DOM objects into GlslCanvas
        // (some implementations may try to parse objects and recurse).
        var dataUrl = c.toDataURL('image/png');
        sandbox.setUniform('u_fox', dataUrl);
        console.log('u_fox uploaded from canvas (dataURL):', c.width, 'x', c.height);
        // also provide texture resolution to shader so we can preserve aspect ratio
        sandbox.setUniform('u_foxResolution', c.width, c.height);
      }catch(e){
        // Fallback: if toDataURL fails (cross-origin / security), fall back to image element
        console.warn('toDataURL failed, falling back to image element:', e);
        sandbox.setUniform('u_fox', img);
        sandbox.setUniform('u_foxResolution', img.naturalWidth || img.width, img.naturalHeight || img.height);
      }
    };
    img.onerror = function(e){
      console.warn('Failed to load fox image, falling back to direct path', e);
      sandbox.setUniform('u_fox', 'data/fox_alpha.png');
    };
  })();
  // u_foxSize 為狐狸佔畫布寬度比例（如 0.12 => 12% 畫布寬度）
  // u_foxSize 初始值設為 slider 的最小值 0.2 (20% 寬度)
  sandbox.setUniform('u_foxSize', 0.2);
  // 初始狐狸所在圖層（0 = 最前；5 = 最後）
  var foxLayer = 0;
  sandbox.setUniform('u_foxLayer', foxLayer);
  // base size (from slider) before per-layer scaling
  var baseFoxSize = 0.2;
  // fox overlay toggle: 1 = overlay on (draw fox after all layers), 0 = respect u_foxLayer
  var foxOverlayToggle = document.getElementById('foxOverlayToggle');
  sandbox.setUniform('u_foxOverlay', foxOverlayToggle && foxOverlayToggle.checked ? 1.0 : 0.0);
  if(foxOverlayToggle){
    foxOverlayToggle.addEventListener('change', function(){ sandbox.setUniform('u_foxOverlay', this.checked ? 1.0 : 0.0); });
  }

  // Layer controls UI
  var foxLayerBackBtn = document.getElementById('foxLayerBackBtn');
  var foxLayerForwardBtn = document.getElementById('foxLayerForwardBtn');
  var foxLayerLabel = document.getElementById('foxLayerLabel');
  if(foxLayerLabel) foxLayerLabel.textContent = String(foxLayer);

  // Safety: prevent extremely fast repeated layer changes
  var _layerChangeLocked = false;
  function _withLayerCooldown(fn){
    if(_layerChangeLocked) return;
    _layerChangeLocked = true;
    try{ fn(); }finally{
      setTimeout(function(){ _layerChangeLocked = false; }, 140);
    }
  }

  function setFoxLayer(newLayer){
    // clamp to valid range 0..5
    var v = Math.max(0, Math.min(5, Math.floor(newLayer)));
    foxLayer = v;
    sandbox.setUniform('u_foxLayer', foxLayer);
    if(foxLayerLabel) foxLayerLabel.textContent = String(foxLayer);
    // apply per-layer scale: shrink by 15% each layer moved back (multiplicative)
    var scaled = baseFoxSize * Math.pow(0.85, foxLayer);
    sandbox.setUniform('u_foxSize', scaled);
  }

  function moveFoxBack(){
    _withLayerCooldown(function(){
      // if overlay was on, disable it so layer changes take effect
      if(foxOverlayToggle && foxOverlayToggle.checked){
        foxOverlayToggle.checked = false;
        sandbox.setUniform('u_foxOverlay', 0.0);
      }
      setFoxLayer(foxLayer + 1);
    });
  }

  function moveFoxForward(){
    _withLayerCooldown(function(){
      if(foxOverlayToggle && foxOverlayToggle.checked){
        foxOverlayToggle.checked = false;
        sandbox.setUniform('u_foxOverlay', 0.0);
      }
      setFoxLayer(foxLayer - 1);
    });
  }

  if(foxLayerBackBtn) foxLayerBackBtn.addEventListener('click', moveFoxBack);
  if(foxLayerForwardBtn) foxLayerForwardBtn.addEventListener('click', moveFoxForward);

  // Keyboard shortcuts: ArrowLeft => move forward (towards front), ArrowRight => move back
  window.addEventListener('keydown', function(e){
    // ignore when typing in inputs/textareas or contenteditable
    var ae = document.activeElement;
    if(ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return;
    if(e.key === 'ArrowLeft'){
      e.preventDefault();
      moveFoxForward();
    } else if(e.key === 'ArrowRight'){
      e.preventDefault();
      moveFoxBack();
    }
  });

  // 點擊 canvas 左鍵讓狐狸往後一層（towards background）移動，超過最後一層則回到最前
  // 目前為了 Debug 穩定性暫時停用點擊切換圖層功能：
  /*
  canvas.addEventListener('mousedown', function(e){
    if(e.button === 0){
      foxLayer = (foxLayer + 1) % 6; // 0..5
      sandbox.setUniform('u_foxLayer', foxLayer);
    }
  });
  */

  // Fox size slider wiring
  var foxSizeSlider = document.getElementById('foxSizeSlider');
  var foxSizeLabel = document.getElementById('foxSizeLabel');
  if(foxSizeSlider){
    // set initial value and uniform
    var initialFoxSize = parseFloat(foxSizeSlider.value);
    // base size (before per-layer scaling)
    baseFoxSize = initialFoxSize;
    // apply per-layer scaling for current layer
    var initialScaled = baseFoxSize * Math.pow(0.70, foxLayer);
    sandbox.setUniform('u_foxSize', initialScaled);
    // map slider range [min..max] -> display 1..100%
    var fsMin = parseFloat(foxSizeSlider.min);
    var fsMax = parseFloat(foxSizeSlider.max);
    var displayPct = Math.round(((initialFoxSize - fsMin) / (fsMax - fsMin)) * 99.0 + 1.0);
    if(foxSizeLabel) foxSizeLabel.textContent = displayPct + '%';
    foxSizeSlider.addEventListener('input', function(){
      var v = parseFloat(this.value);
      // update base size and recompute scaled size according to current layer
      baseFoxSize = v;
      var scaled = baseFoxSize * Math.pow(0.70, foxLayer);
      sandbox.setUniform('u_foxSize', scaled);
      var fsMin = parseFloat(this.min);
      var fsMax = parseFloat(this.max);
      var displayPct = Math.round(((v - fsMin) / (fsMax - fsMin)) * 99.0 + 1.0);
      if(foxSizeLabel) foxSizeLabel.textContent = displayPct + '%';
    });
  }
  // Fox feather slider wiring
  // Fox feather fixed to 20px (slider removed)
  sandbox.setUniform('u_foxFeather', 20.0);

  // 偵測 u_fox texture 是否有正確載入，並在載入完成時回報到 console（不要自動關閉偵錯）
  setTimeout(function(){
    console.log('GlslCanvas textures snapshot:', Object.keys(sandbox.textures || {}));
    var foxTex = sandbox.textures && sandbox.textures['u_fox'];
    if(foxTex){
      foxTex.on('loaded', function(){
        console.log('u_fox loaded:', foxTex.width, 'x', foxTex.height, 'src=', foxTex.source);
      });
      if(foxTex.width && foxTex.height){
        console.log('u_fox already loaded:', foxTex.width, 'x', foxTex.height, 'src=', foxTex.source);
      }
    } else {
      console.warn('u_fox texture not found in sandbox.textures');
    }
    // 不主動改變偵錯模式，由 UI 控制
    // 在 console 顯示目前 u_mouse（pixel）以便確認
    try{ console.log('initial u_mouse (px):', canvas.width/2, canvas.height/2); }catch(e){}
  }, 200);

  // 確保 shader 能接收到滑鼠座標：手動在 JS 層傳入 u_mouse（像素空間），
  // 因為 GlslCanvas 只有在 shader 中出現多次 u_mouse 時才會自動更新。
  function updateMouseUniform(e){
    var rect = canvas.getBoundingClientRect();
    // Map CSS mouse coordinates to the canvas drawing buffer pixel coordinates
    // canvas.width/height are the actual drawingbuffer sizes (may be scaled by DPR)
    var cssX = e.clientX - rect.left;
    var cssY = e.clientY - rect.top;
    var mx = cssX * (canvas.width / rect.width);
    var my = canvas.height - cssY * (canvas.height / rect.height);
    sandbox.setUniform('u_mouse', mx, my);
    // compute horizontal velocity (px/s) and update flip target accordingly
    var now = (window.performance && performance.now) ? performance.now() : Date.now();
    if(_prevMouseX === null || _prevTime === null){
      _prevMouseX = mx;
      _prevTime = now;
    }
    var dt = Math.max(1.0, now - _prevTime); // ms
    var vx = (mx - _prevMouseX) / (dt / 1000.0); // px/s
    // update target: moving right -> 1.0, moving left -> 0.0
    if(vx > _flipThreshold) _foxFlipTarget = 1.0;
    else if(vx < -_flipThreshold) _foxFlipTarget = 0.0;
    // remember previous for next velocity calc
    _prevMouseX = mx;
    _prevTime = now;
    // debug log for verification
    if(window.__mouseDebugCounter === undefined) window.__mouseDebugCounter = 0;
    if((window.__mouseDebugCounter++ % 50) === 0){
      console.log('u_mouse (px)=', mx.toFixed(1), my.toFixed(1), 'canvas draw size=', canvas.width, 'x', canvas.height, 'rect size=', rect.width.toFixed(1), 'x', rect.height.toFixed(1));
    }
  }
  canvas.addEventListener('mousemove', updateMouseUniform);
  // 設定初始滑鼠位置為畫布中心
  // set initial mouse to canvas center using drawingbuffer coordinates
  (function setInitialMouse(){
    // Delay slightly to allow GlslCanvas to resize the drawingbuffer
    setTimeout(function(){
      var mx = canvas.width / 2.0;
      var my = canvas.height / 2.0;
      sandbox.setUniform('u_mouse', mx, my);
      // set initial flip based on center (defaults to not flipped)
      var initialFlip = (mx > (canvas.width * 0.5)) ? 1.0 : 0.0;
      _foxFlipValue = initialFlip;
      _foxFlipTarget = initialFlip;
      sandbox.setUniform('u_foxFlip', initialFlip);
      // initialize prev mouse/time for velocity calc
      _prevMouseX = mx;
      _prevTime = (window.performance && performance.now) ? performance.now() : Date.now();
      // DOM fox removed; no DOM positioning necessary
      console.log('initial u_mouse (px)=', mx, my, 'canvas draw size=', canvas.width, 'x', canvas.height);
    }, 100);
  })();
  // no DOM fox overlay to synchronize

  // Position UI to be vertically centered and fixed to the canvas left edge.
  function positionUI(){
    var ui = document.getElementById('ui');
    if(!canvas || !ui) return;
    var crect = canvas.getBoundingClientRect();
    // ensure ui has been laid out to get correct size
    var uiW = ui.offsetWidth || 240;
    var uiH = ui.offsetHeight || 180;
    // place ui so its right edge is a small gap from canvas left edge
    var gap = 12;
    var left = Math.round(crect.left - uiW - gap);
    // if not enough space on left, clamp to 10px
    if(left < 10) left = 10;
    var top = Math.round(crect.top + crect.height/2 - uiH/2);
    if(top < 10) top = 10;
    ui.style.left = left + 'px';
    ui.style.top = top + 'px';
    ui.style.transform = 'none';
  }

  // reposition on load and when window resizes (or when canvas layout changes)
  window.addEventListener('load', positionUI);
  window.addEventListener('resize', function(){
    // debounce a bit
    clearTimeout(window._positionUITimeout);
    window._positionUITimeout = setTimeout(positionUI, 80);
  });
  // also reposition shortly after initial apply to account for fonts/images
  setTimeout(positionUI, 120);
</script>

</html>